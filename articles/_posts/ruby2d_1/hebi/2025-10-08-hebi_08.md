---
layout: post
part: Ruby2D(1)
title: ヘビゲーム
categories: [ruby2d_1, hebi]
chapter: 1
section: 8
section_title: 胴体の判定を作る
description: 最初のステップ。スクラッチの始め方を紹介します。
---

## {{ page.section_title }}

### 自機のパラメーターを調整

`body_size` を `20` に変更します。

main.rb
```
(略)
# ヘビの胴体
body_size = 30
logs = (body_size * speed + 1).times.map { |i| [head.x - speed * i, head.y + speed * i] }
bodies = body_size.times.map { |i| Circle.new(radius: 8, x: logs[speed * i].first, y: logs[speed * i].last) }

(略)
```

### あたり判定用のメソッドを追加する

main.rb
```
(略)
message.each { |text| text.remove }

# すでに頭に当たっている2個目以降の胴体の数
touched_count = bodies[1, body_size - 1].select { |body| body.contains?(head.x, head.y) }.size

def hit(head)
  # 上の当たり判定
  top = head.contains?(head.x, 0)
  # 下の当たり判定
  bottom = head.contains?(head.x, Window.height)
  # 右の当たり判定
  right = head.contains?(Window.width, head.y)
  # 左の当たり判定
  left = head.contains?(0, head.y)
  top || bottom || right || left
end

def touch(head, bodies, touched_count)
  current_touch_count = bodies[1, bodies.size - 1].select { |body| body.contains?(head.x, head.y) }.size
  current_touch_count > touched_count
end

on :key_down do |event|
(略)
```

### 判定を追加する

main.rb
```
(略)
update do
  case status
  when :game_start
    # 当たり判定
    if hit(head) || touch(head, bodies, touched_count)
      status = :game_over
(略)
```

### ファイルの実行

bash
```
$ ruby main.rb
```

### 結果

胴体に当たるとゲームオーバーになる。

うまくいったらここで、

```
p logs # 追従用の座標群
p [head.x, head.y] # 頭の座標
p bodies.map { |o| [o.x, o.y] } # 胴体の座標群
```

は不要になるので、削除しておきます。

### ここまでのコード

main.rb
```
require "ruby2d"

# ヘビの頭
head = Circle.new(radius: 10)
head.x = Window.width / 2
head.y = Window.height / 2
speed = 3
x_flug = true
y_flug = false
status = :stop

# ヘビの胴体
body_size = 20
logs = (body_size * speed + 1).times.map { |i| [head.x - speed * i, head.y + speed * i] }
bodies = body_size.times.map { |i| Circle.new(radius: 8, x: logs[speed * i].first, y: logs[speed * i].last) }

# ゲームオーバー画面
message = [
  Text.new("GAME OVER", size: 30, x: 220, y: 150),
  Text.new("press key 'R' to restart", size: 20, x: 205, y: 300)
]
message.each { |text| text.remove }

# すでに頭に当たっている2個目以降の胴体の数
touched_count = bodies[1, body_size - 1].select { |body| body.contains?(head.x, head.y) }.size

def hit(head)
  # 上の当たり判定
  top = head.contains?(head.x, 0)
  # 下の当たり判定
  bottom = head.contains?(head.x, Window.height)
  # 右の当たり判定
  right = head.contains?(Window.width, head.y)
  # 左の当たり判定
  left = head.contains?(0, head.y)
  top || bottom || right || left
end

def touch(head, bodies, touched_count)
  current_touch_count = bodies[1, bodies.size - 1].select { |body| body.contains?(head.x, head.y) }.size
  current_touch_count > touched_count
end

on :key_down do |event|
  # ゲームスタート
  if event.key == "right" || event.key == "left"
    status = :game_start if status == :stop
  end
  # リスタート
  if event.key == "r" && status == :game_over
    status = :stop
    head.x = Window.width / 2
    head.y = Window.height / 2
    x_flug = true
    y_flug = false
    logs = (body_size * speed + 1).times.map { |i| [head.x - speed * i, head.y + speed * i] }
    bodies.each { |body| body.remove }
    bodies = body_size.times.map { |i| Circle.new(radius: 8, x: logs[speed * i].first, y: logs[speed * i].last) }
    message.each { |text| text.remove }
  end
  # 右上に移動の時
  if x_flug && !y_flug
    case event.key
    when "right"
      y_flug = true
    when "left"
      x_flug = false
    end
  # 左上に移動の時
  elsif !x_flug && !y_flug
    case event.key
    when "right"
      x_flug = true
    when "left"
      y_flug = true
    end
  # 右下に移動の時
  elsif x_flug && y_flug
    case event.key
    when "right"
      x_flug = false
    when "left"
      y_flug = false
    end
  # 左下に移動の時
  elsif !x_flug && y_flug
    case event.key
    when "right"
      y_flug = false
    when "left"
      x_flug = true
    end
  end
end

update do
  case status
  when :game_start
    # 当たり判定
    if hit(head) || touch(head, bodies, touched_count)
      status = :game_over
      message.each { |text| text.add }
    end
    # 移動方向の管理
    if x_flug
      head.x += speed
    else
      head.x -= speed
    end
    if y_flug
      head.y += speed
    else
      head.y -= speed
    end
    # logの更新
    logs.unshift([head.x, head.y])
    logs.pop
    # 胴体の更新
    bodies.each.with_index(1) do |body, i|
      body.x = logs[speed * i].first
      body.y = logs[speed * i].last
    end
  end
end

show
```